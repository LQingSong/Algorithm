# 程序 = 数据结构 + 算法

## 1. 在一个数组中[3, 4, 2, 1, 5, 7] 有一个需求 sum（arr, L, R）求 L 到 R 的累加和,sum 查询频繁，请设计一个合理的算法

预处理结构：

- 设计 1：通过二维数组建立一个表，后续查表（L，R）坐标就可以直接取值

| L R | 0   | 1   | 2   | 3   | 4   | 5   |
| --- | --- | --- | --- | --- | --- | --- |
| 0   | 3   | 7   | 9   | 10  | 15  | 21  |
| 1   | X   | 4   | 6   | 7   | 12  | 19  |
| 2   | X   | X   | 2   | 3   | 4   | 11  |
| 3   | X   | X   | X   | 1   | 6   | 13  |
| 4   | X   | X   | X   | X   | 5   | 12  |
| 5   | X   | X   | X   | X   | X   | 7   |

Sum[0, 2] = 9
Sum[1, 3] = 7

- 设计 2: 由于建立一个二维表比较麻烦，引出一维表 —— 前缀数组
  - Help: [3, 7, 9, 10, 15, 21]

Sum[0, 2] = H[2] = 9
Sum[1, 3] = H[3] - H[0] = 10 - 3 = 7
Sum[L, R]:

- 当 L == 0, sum[L, R] = H[R]
- 当 L ≠ 0, sum[L, R] - H[R] - H[L]

### 总结： 设计 1 和设计 2，通常情况下认为前缀数组比建二维表的方式好，节省更多空间；但是如果 sum 查询的次数消耗大于建表的消耗时，也就是查询非常频繁的情况下，设计 1 会比设计 2 更好

## 2. random() 等概率返回[0, 1)之间的数

- 等概率
- 左闭右开 0 ~ 1
- Int(Math.random() \* k) => [0, k-1]
- Max(Math.random(), Math.random()) => 返回[0, k²]
- Max(Math.random(), Max(Math.random(),Math.random)) => 返回[0, k³]
- Min(Math.random(), Math.random()) => 1 - (1-x)²
- 0 ~ 1 发生器
- 不等概率
- 对数器

## 动态数组有扩容代价，但是从时间复杂度来看，均摊下来几乎是常数操作 O(1)的。

## 哈希表 和 有序表 Java 中有有序表，但是在 js 中没有 TreeMap

1. HashMap 增删改查是 O(1)的，但是这个固定常数时间是比数组索引这些要大
2. 有序表 TreeMap 增删改查全是 O(logN)
